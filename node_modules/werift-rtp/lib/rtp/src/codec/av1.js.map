{"version":3,"file":"av1.js","sourceRoot":"","sources":["../../../../src/codec/av1.ts"],"names":[],"mappings":"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","sourcesContent":["// RTP Payload Format For AV1 https://aomediacodec.github.io/av1-rtp-spec/\n\nimport { LEB128 } from \"@minhducsun2002/leb128\";\n\nimport type { RtpHeader } from \"..\";\nimport { BitWriter2, debug, getBit } from \"../imports/common\";\n\nconst log = debug(\"werift-rtp : packages/rtp/src/codec/av1.ts\");\n\n// 4.4 AV1 Aggregation Header\n//  0 1 2 3 4 5 6 7\n// +-+-+-+-+-+-+-+-+\n// |Z|Y| W |N|-|-|-|\n// +-+-+-+-+-+-+-+-+\n\n// RTP payload syntax:\n// 0                   1                   2                   3\n// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n// |Z|Y|0 0|N|-|-|-|  OBU element 1 size (leb128)  |               |\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |\n// :                                                               :\n// :                      OBU element 1 data                       :\n// :                                                               :\n// |                                                               |\n// |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n// |                               |  OBU element 2 size (leb128)  |\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n// :                                                               :\n// :                       OBU element 2 data                      :\n// :                                                               :\n// |                                                               |\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n// :                                                               :\n// :                              ...                              :\n// :                                                               :\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n// |OBU e... N size|                                               |\n// +-+-+-+-+-+-+-+-+       OBU element N data      +-+-+-+-+-+-+-+-+\n// |                                               |\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n// OBU syntax:\n//     0 1 2 3 4 5 6 7\n//    +-+-+-+-+-+-+-+-+\n//    |0| type  |X|S|-| (REQUIRED)\n//    +-+-+-+-+-+-+-+-+\n// X: | TID |SID|-|-|-| (OPTIONAL)\n//    +-+-+-+-+-+-+-+-+\n//    |1|             |\n//    +-+ OBU payload |\n// S: |1|             | (OPTIONAL, variable length leb128 encoded)\n//    +-+    size     |\n//    |0|             |\n//    +-+-+-+-+-+-+-+-+\n//    |  OBU payload  |\n//    |     ...       |\n\nexport class AV1RtpPayload {\n  /**\n   * RtpStartsWithFragment\n   * MUST be set to 1 if the first OBU element is an OBU fragment that is a continuation of an OBU fragment from the previous packet, and MUST be set to 0 otherwise.\n   */\n  zBit_RtpStartsWithFragment!: number;\n  /**\n   * RtpEndsWithFragment\n   * MUST be set to 1 if the last OBU element is an OBU fragment that will continue in the next packet, and MUST be set to 0 otherwise.\n   */\n  yBit_RtpEndsWithFragment!: number;\n  /**\n   * RtpNumObus\n   * two bit field that describes the number of OBU elements in the packet. This field MUST be set equal to 0 or equal to the number of OBU elements contained in the packet. If set to 0, each OBU element MUST be preceded by a length field.\n   */\n  w_RtpNumObus!: number;\n  /**\n   * RtpStartsNewCodedVideoSequence\n   * MUST be set to 1 if the packet is the first packet of a coded video sequence, and MUST be set to 0 otherwise.\n   */\n  nBit_RtpStartsNewCodedVideoSequence!: number;\n  obu_or_fragment: { data: Buffer; isFragment: boolean }[] = [];\n\n  static deSerialize = (buf: Buffer) => {\n    const p = new AV1RtpPayload();\n\n    let offset = 0;\n\n    p.zBit_RtpStartsWithFragment = getBit(buf[offset], 0);\n    p.yBit_RtpEndsWithFragment = getBit(buf[offset], 1);\n    p.w_RtpNumObus = getBit(buf[offset], 2, 2);\n    p.nBit_RtpStartsNewCodedVideoSequence = getBit(buf[offset], 4);\n    offset++;\n\n    if (p.nBit_RtpStartsNewCodedVideoSequence && p.zBit_RtpStartsWithFragment) {\n      throw new Error();\n    }\n\n    [...Array(p.w_RtpNumObus - 1).keys()].forEach((i) => {\n      const [elementSize, bytes] = leb128decode(buf.subarray(offset));\n\n      const start = offset + bytes;\n      const end = start + elementSize;\n\n      let isFragment = false;\n      if (p.zBit_RtpStartsWithFragment && i === 0) {\n        isFragment = true;\n      }\n      p.obu_or_fragment.push({ data: buf.subarray(start, end), isFragment });\n\n      offset += bytes + elementSize;\n    });\n    let isFragment = false;\n    if (\n      p.yBit_RtpEndsWithFragment ||\n      (p.w_RtpNumObus === 1 && p.zBit_RtpStartsWithFragment)\n    ) {\n      isFragment = true;\n    }\n    p.obu_or_fragment.push({\n      data: buf.subarray(offset),\n      isFragment: isFragment,\n    });\n\n    return p;\n  };\n\n  static isDetectedFinalPacketInSequence(header: RtpHeader) {\n    return header.marker;\n  }\n\n  get isKeyframe() {\n    return this.nBit_RtpStartsNewCodedVideoSequence === 1;\n  }\n\n  static getFrame(payloads: AV1RtpPayload[]) {\n    const frames: Buffer[] = [];\n    const objects = payloads\n      .flatMap((p) => p.obu_or_fragment)\n      .reduce(\n        (\n          acc: Record<number, { data: Buffer; isFragment: boolean }>,\n          cur,\n          i,\n        ) => {\n          acc[i] = cur;\n          return acc;\n        },\n        {},\n      );\n    const length = Object.keys(objects).length;\n\n    for (const i of Object.keys(objects).map(Number)) {\n      const exist = objects[i];\n      if (!exist) continue;\n      const { data, isFragment } = exist;\n      if (isFragment) {\n        let fragments: Buffer[] = [];\n        for (let head = i; head < length; head++) {\n          const target = objects[head];\n          if (target.isFragment) {\n            fragments.push(target.data);\n            delete objects[head];\n          } else {\n            break;\n          }\n        }\n        if (fragments.length <= 1) {\n          log(\"fragment lost, maybe packet lost\");\n          fragments = [];\n        }\n        frames.push(Buffer.concat(fragments));\n      } else {\n        frames.push(data);\n      }\n    }\n    const obus = frames.map((f) => AV1Obu.deSerialize(f));\n    const lastObu = obus.pop()!;\n    return Buffer.concat([\n      ...obus.map((o) => {\n        o.obu_has_size_field = 1;\n        return o.serialize();\n      }),\n      lastObu.serialize(),\n    ]);\n  }\n}\n\nexport class AV1Obu {\n  obu_forbidden_bit!: number;\n  obu_type!: OBU_TYPE;\n  obu_extension_flag!: number;\n  obu_has_size_field!: number;\n  obu_reserved_1bit!: number;\n  payload!: Buffer;\n\n  static deSerialize(buf: Buffer) {\n    const obu = new AV1Obu();\n    let offset = 0;\n    obu.obu_forbidden_bit = getBit(buf[offset], 0);\n    obu.obu_type =\n      OBU_TYPES[getBit(buf[offset], 1, 4) as keyof typeof OBU_TYPES];\n    obu.obu_extension_flag = getBit(buf[offset], 5);\n    obu.obu_has_size_field = getBit(buf[offset], 6);\n    obu.obu_reserved_1bit = getBit(buf[offset], 7);\n    offset++;\n\n    obu.payload = buf.subarray(offset);\n\n    return obu;\n  }\n\n  serialize() {\n    const header = new BitWriter2(8)\n      .set(this.obu_forbidden_bit)\n      .set(OBU_TYPE_IDS[this.obu_type], 4)\n      .set(this.obu_extension_flag)\n      .set(this.obu_has_size_field)\n      .set(this.obu_reserved_1bit).buffer;\n    let obuSize: Uint8Array | Buffer = Buffer.alloc(0);\n    if (this.obu_has_size_field) {\n      obuSize = LEB128.encode(this.payload.length);\n    }\n    return Buffer.concat([header, obuSize, this.payload]);\n  }\n}\n\nexport function leb128decode(buf: Buffer) {\n  let value = 0;\n  let leb128bytes = 0;\n  for (let i = 0; i < 8; i++) {\n    const leb128byte = buf.readUInt8(i);\n    value |= (leb128byte & 0x7f) << (i * 7);\n    leb128bytes++;\n    if (!(leb128byte & 0x80)) {\n      break;\n    }\n  }\n  return [value, leb128bytes];\n}\n\nconst OBU_TYPES = {\n  0: \"Reserved\",\n  1: \"OBU_SEQUENCE_HEADER\",\n  2: \"OBU_TEMPORAL_DELIMITER\",\n  3: \"OBU_FRAME_HEADER\",\n  4: \"OBU_TILE_GROUP\",\n  5: \"OBU_METADATA\",\n  6: \"OBU_FRAME\",\n  7: \"OBU_REDUNDANT_FRAME_HEADER\",\n  8: \"OBU_TILE_LIST\",\n  15: \"OBU_PADDING\",\n} as const;\ntype OBU_TYPE = (typeof OBU_TYPES)[keyof typeof OBU_TYPES];\nconst OBU_TYPE_IDS: Record<OBU_TYPE, number> = Object.entries(OBU_TYPES).reduce(\n  (acc: any, [key, value]) => {\n    acc[value] = Number(key);\n    return acc;\n  },\n  {},\n);\n"]}