{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/codec/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAeA,sDA4DC;AA1ED,+BAAsC;AAEtC,iCAAwC;AACxC,iCAAwC;AACxC,+BAAsC;AACtC,+BAAsC;AAEtC,wCAAsB;AACtB,yCAAuB;AACvB,yCAAuB;AACvB,yCAAuB;AACvB,wCAAsB;AACtB,wCAAsB;AAEtB,SAAgB,qBAAqB,CACnC,KAAwB,EACxB,OAAoB,EACpB,mBAA4B;IAQ5B,MAAM,gBAAgB,GAAG,CAAC,YAAqC,EAAE,EAAE;QACjE,MAAM,UAAU,GAAuB,EAAE,CAAC;QAC1C,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE,CAAC;YACxB,MAAM,KAAK,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;YACvE,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;gBACnB,mBAAmB,KAAnB,mBAAmB,GAAK,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAC;gBACxC,mBAAmB,GAAG,KAAK,CAAC,QAAQ,CAAC;YACvC,CAAC;iBAAM,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;gBACzB,mBAAmB,GAAG,SAAS,CAAC;YAClC,CAAC;YACD,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACzB,CAAC;QACD,MAAM,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;QAC1D,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CACxB,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAClD,CAAC;QAEF,OAAO;YACL,UAAU;YACV,IAAI;YACJ,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,cAAc,IAAI,CAAC;YACpD,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,SAAS,IAAI,CAAC;YAChD,mBAAmB;SACpB,CAAC;IACJ,CAAC,CAAC;IAEF,QAAQ,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC;QAC5B,KAAK,KAAK,CAAC,CAAC,CAAC;YACX,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,mBAAa,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACxE,MAAM,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,IAAI,GAAG,mBAAa,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC5C,OAAO;gBACL,UAAU;gBACV,IAAI;gBACJ,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,cAAc,IAAI,CAAC;gBACpD,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,SAAS,IAAI,CAAC;aACjD,CAAC;QACJ,CAAC;QACD,KAAK,eAAe;YAClB,OAAO,gBAAgB,CAAC,qBAAc,CAAC,CAAC;QAC1C,KAAK,KAAK;YACR,OAAO,gBAAgB,CAAC,mBAAa,CAAC,CAAC;QACzC,KAAK,KAAK;YACR,OAAO,gBAAgB,CAAC,mBAAa,CAAC,CAAC;QACzC,KAAK,MAAM;YACT,OAAO,gBAAgB,CAAC,qBAAc,CAAC,CAAC;QAC1C;YACE,MAAM,IAAI,KAAK,EAAE,CAAC;IACtB,CAAC;AACH,CAAC;AAEY,QAAA,kBAAkB,GAAG;IAChC,eAAe;IACf,KAAK;IACL,KAAK;IACL,MAAM;IACN,KAAK;CACG,CAAC","sourcesContent":["import type { RtpPacket } from \"../rtp/rtp\";\nimport { AV1RtpPayload } from \"./av1\";\nimport type { DePacketizerBase } from \"./base\";\nimport { H264RtpPayload } from \"./h264\";\nimport { OpusRtpPayload } from \"./opus\";\nimport { Vp8RtpPayload } from \"./vp8\";\nimport { Vp9RtpPayload } from \"./vp9\";\n\nexport * from \"./av1\";\nexport * from \"./base\";\nexport * from \"./h264\";\nexport * from \"./opus\";\nexport * from \"./vp8\";\nexport * from \"./vp9\";\n\nexport function dePacketizeRtpPackets(\n  codec: DepacketizerCodec,\n  packets: RtpPacket[],\n  frameFragmentBuffer?: Buffer,\n): {\n  isKeyframe: boolean;\n  data: Buffer;\n  sequence: number;\n  timestamp: number;\n  frameFragmentBuffer?: Buffer;\n} {\n  const basicCodecParser = (Depacketizer: typeof DePacketizerBase) => {\n    const partitions: DePacketizerBase[] = [];\n    for (const p of packets) {\n      const codec = Depacketizer.deSerialize(p.payload, frameFragmentBuffer);\n      if (codec.fragment) {\n        frameFragmentBuffer ??= Buffer.alloc(0);\n        frameFragmentBuffer = codec.fragment;\n      } else if (codec.payload) {\n        frameFragmentBuffer = undefined;\n      }\n      partitions.push(codec);\n    }\n    const isKeyframe = !!partitions.find((f) => f.isKeyframe);\n    const data = Buffer.concat(\n      partitions.map((f) => f.payload).filter((p) => p),\n    );\n\n    return {\n      isKeyframe,\n      data,\n      sequence: packets.at(-1)?.header.sequenceNumber ?? 0,\n      timestamp: packets.at(-1)?.header.timestamp ?? 0,\n      frameFragmentBuffer,\n    };\n  };\n\n  switch (codec.toUpperCase()) {\n    case \"AV1\": {\n      const chunks = packets.map((p) => AV1RtpPayload.deSerialize(p.payload));\n      const isKeyframe = !!chunks.find((f) => f.isKeyframe);\n      const data = AV1RtpPayload.getFrame(chunks);\n      return {\n        isKeyframe,\n        data,\n        sequence: packets.at(-1)?.header.sequenceNumber ?? 0,\n        timestamp: packets.at(-1)?.header.timestamp ?? 0,\n      };\n    }\n    case \"MPEG4/ISO/AVC\":\n      return basicCodecParser(H264RtpPayload);\n    case \"VP8\":\n      return basicCodecParser(Vp8RtpPayload);\n    case \"VP9\":\n      return basicCodecParser(Vp9RtpPayload);\n    case \"OPUS\":\n      return basicCodecParser(OpusRtpPayload);\n    default:\n      throw new Error();\n  }\n}\n\nexport const depacketizerCodecs = [\n  \"MPEG4/ISO/AVC\",\n  \"VP8\",\n  \"VP9\",\n  \"OPUS\",\n  \"AV1\",\n] as const;\nexport type DepacketizerCodec =\n  | (typeof depacketizerCodecs)[number]\n  | Lowercase<(typeof depacketizerCodecs)[number]>;\n"]}