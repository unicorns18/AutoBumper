{"version":3,"file":"h264.js","sourceRoot":"","sources":["../../../../src/codec/h264.ts"],"names":[],"mappings":"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","sourcesContent":["// RFC 6184 - RTP Payload Format for H.264 Video\n// pion/rtp\n\nimport { BitStream, getBit } from \"../../../common/src\";\nimport type { RtpHeader } from \"../rtp/rtp\";\nimport type { DePacketizerBase } from \"./base\";\n\n// FU indicator octet\n// +---------------+\n// |0|1|2|3|4|5|6|7|\n// +-+-+-+-+-+-+-+-+\n// |F|NRI|  Type   |\n// +---------------+\n\n// FU header\n// +---------------+\n// |0|1|2|3|4|5|6|7|\n// +-+-+-+-+-+-+-+-+\n// |S|E|R|  Type   |\n// +---------------+\n\n// NAL Unit Type     Content of NAL Unit              NRI (binary)\n// ----------------------------------------------------------------\n//  1              non-IDR coded slice                         10\n//  2              Coded slice data partition A                10\n//  3              Coded slice data partition B                01\n//  4              Coded slice data partition C                01\n\n// Payload Packet    Single NAL    Non-Interleaved    Interleaved\n// Type    Type      Unit Mode           Mode             Mode\n// -------------------------------------------------------------\n// 0      reserved      ig               ig               ig\n// 1-23   NAL unit     yes              yes               no\n// 24     STAP-A        no              yes               no\n// 25     STAP-B        no               no              yes\n// 26     MTAP16        no               no              yes\n// 27     MTAP24        no               no              yes\n// 28     FU-A          no              yes              yes\n// 29     FU-B          no               no              yes\n// 30-31  reserved      ig               ig               ig\n\nexport class H264RtpPayload implements DePacketizerBase {\n  /**forbidden_zero_bit */\n  f!: number;\n  /**nal_ref_idc */\n  nri!: number;\n  /**nal_unit_types */\n  nalUnitType!: number;\n  /**start of a fragmented NAL unit */\n  s!: number;\n  /**end of a fragmented NAL unit */\n  e!: number;\n  r!: number;\n  nalUnitPayloadType!: number;\n  payload!: Buffer;\n  fragment?: Buffer;\n\n  static deSerialize(buf: Buffer, fragment?: Buffer) {\n    const h264 = new H264RtpPayload();\n\n    let offset = 0;\n\n    const naluHeader = buf[offset];\n    h264.f = getBit(naluHeader, 0);\n    h264.nri = getBit(naluHeader, 1, 2);\n    h264.nalUnitType = getBit(naluHeader, 3, 5);\n    offset++;\n\n    h264.s = getBit(buf[offset], 0);\n    h264.e = getBit(buf[offset], 1);\n    h264.r = getBit(buf[offset], 2);\n    h264.nalUnitPayloadType = getBit(buf[offset], 3, 5);\n    offset++;\n\n    // デフォルトでは packetization-mode=0\n    // packetization-mode=0だとSingle NAL Unit Packetしか来ない\n    // https://datatracker.ietf.org/doc/html/rfc6184#section-6.2\n\n    // Single NAL Unit Packet\n    if (0 < h264.nalUnitType && h264.nalUnitType < NalUnitType.stap_a) {\n      h264.payload = this.packaging(buf);\n    }\n    // Single-time aggregation packet\n    else if (h264.nalUnitType === NalUnitType.stap_a) {\n      let offset = stap_aHeaderSize;\n      let result: Buffer = Buffer.alloc(0);\n      while (offset < buf.length) {\n        const naluSize = buf.readUInt16BE(offset);\n        offset += stap_aNALULengthSize;\n\n        result = Buffer.concat([\n          result,\n          this.packaging(buf.subarray(offset, offset + naluSize)),\n        ]);\n        offset += naluSize;\n      }\n      h264.payload = result;\n    }\n    // Fragmentation Units\n    else if (h264.nalUnitType === NalUnitType.fu_a) {\n      if (!fragment) {\n        fragment = Buffer.alloc(0);\n      }\n      const fu = buf.subarray(offset);\n      h264.fragment = Buffer.concat([fragment, fu]);\n\n      if (h264.e) {\n        const bitStream = new BitStream(Buffer.alloc(1))\n          .writeBits(1, 0)\n          .writeBits(2, h264.nri)\n          .writeBits(5, h264.nalUnitPayloadType);\n        const nalu = Buffer.concat([bitStream.uint8Array, h264.fragment]);\n        h264.fragment = undefined;\n        h264.payload = this.packaging(nalu);\n      }\n    }\n\n    return h264;\n  }\n\n  private static packaging(buf: Buffer) {\n    return Buffer.concat([annex_bNALUStartCode, buf]);\n  }\n\n  static isDetectedFinalPacketInSequence(header: RtpHeader) {\n    return header.marker;\n  }\n\n  get isKeyframe() {\n    return (\n      this.nalUnitType === NalUnitType.idrSlice ||\n      this.nalUnitPayloadType === NalUnitType.idrSlice\n    );\n  }\n\n  get isPartitionHead() {\n    if (\n      this.nalUnitType === NalUnitType.fu_a ||\n      this.nalUnitType === NalUnitType.fu_b\n    ) {\n      return this.s !== 0;\n    }\n\n    return true;\n  }\n}\n\nexport const NalUnitType = {\n  idrSlice: 5,\n  stap_a: 24,\n  stap_b: 25,\n  mtap16: 26,\n  mtap24: 27,\n  fu_a: 28,\n  fu_b: 29,\n} as const;\n\nconst annex_bNALUStartCode = Buffer.from([0x00, 0x00, 0x00, 0x01]);\n\nconst stap_aHeaderSize = 1;\nconst stap_aNALULengthSize = 2;\n"]}