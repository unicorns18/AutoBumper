{"version":3,"file":"depacketizer.js","sourceRoot":"","sources":["../../../../../src/extra/processor/depacketizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, debug } from \"../../imports/common\";\n\nimport {\n  type DepacketizerCodec,\n  type RtpHeader,\n  type RtpPacket,\n  dePacketizeRtpPackets,\n  enumerate,\n  uint16Add,\n  uint16Gt,\n} from \"../..\";\nimport type { Processor } from \"./interface\";\n\nconst path = `werift-rtp : packages/rtp/src/processor/depacketizer.ts`;\nconst log = debug(path);\n\nexport type DepacketizerInput = {\n  rtp?: RtpPacket;\n  /**ms */\n  time?: number;\n  eol?: boolean;\n};\n\nexport interface DepacketizerOutput {\n  frame?: CodecFrame;\n  eol?: boolean;\n}\n\nexport interface CodecFrame {\n  data: Buffer;\n  isKeyframe: boolean;\n  /**ms */\n  time: number;\n  [key: string]: any;\n}\n\nexport interface DepacketizerOptions {\n  isFinalPacketInSequence?: (header: RtpHeader) => boolean;\n  waitForKeyframe?: boolean;\n}\n\nexport class DepacketizeBase\n  implements Processor<DepacketizerInput, DepacketizerOutput>\n{\n  private rtpBuffer: DepacketizerInput[] = [];\n  private frameFragmentBuffer?: Buffer;\n  private lastSeqNum?: number;\n  private frameBroken = false;\n  private keyframeReceived = false;\n  private count = 0;\n  readonly onNeedKeyFrame = new Event();\n  private internalStats = {};\n\n  constructor(\n    private codec: DepacketizerCodec,\n    private options: DepacketizerOptions = {},\n  ) {}\n\n  toJSON(): Record<string, any> {\n    return {\n      ...this.internalStats,\n      codec: this.codec,\n      bufferingLength: this.rtpBuffer.length,\n      lastSeqNum: this.lastSeqNum,\n      count: this.count,\n    };\n  }\n\n  processInput(input: DepacketizerInput): DepacketizerOutput[] {\n    const output: DepacketizerOutput[] = [];\n    if (!input.rtp) {\n      if (input.eol) {\n        output.push({ eol: true });\n        this.stop();\n      }\n      return output;\n    }\n\n    if (this.options.isFinalPacketInSequence) {\n      const isFinal = this.checkFinalPacket(input);\n      if (isFinal) {\n        try {\n          const { data, isKeyframe, sequence, timestamp, frameFragmentBuffer } =\n            dePacketizeRtpPackets(\n              this.codec,\n              this.rtpBuffer.map((b) => b.rtp!),\n              this.frameFragmentBuffer,\n            );\n          this.frameFragmentBuffer = frameFragmentBuffer;\n\n          if (isKeyframe) {\n            this.keyframeReceived = true;\n          }\n\n          if (this.options.waitForKeyframe && this.keyframeReceived === false) {\n            this.onNeedKeyFrame.execute();\n            return [];\n          }\n\n          if (!this.frameBroken && data.length > 0) {\n            const time = this.rtpBuffer.at(-1)?.time ?? 0;\n            output.push({\n              frame: {\n                data,\n                isKeyframe,\n                time,\n                sequence: this.count++,\n                rtpSeq: sequence,\n                timestamp,\n              },\n            });\n            this.internalStats[\"depacketizer\"] = new Date().toISOString();\n          }\n\n          if (this.frameBroken) {\n            this.frameBroken = false;\n          }\n\n          this.clearBuffer();\n\n          return output;\n        } catch (error) {\n          log(\"error\", error, { input, codec: this.codec });\n          this.clearBuffer();\n        }\n      }\n    } else {\n      try {\n        const { data, isKeyframe, sequence, timestamp, frameFragmentBuffer } =\n          dePacketizeRtpPackets(\n            this.codec,\n            [input.rtp],\n            this.frameFragmentBuffer,\n          );\n        this.frameFragmentBuffer = frameFragmentBuffer;\n        output.push({\n          frame: {\n            data,\n            isKeyframe,\n            time: input.time!,\n            sequence: this.count++,\n            rtpSeq: sequence,\n            timestamp,\n          },\n        });\n        this.internalStats[\"depacketizer\"] = new Date().toISOString();\n        return output;\n      } catch (error) {\n        log(\"error\", error, { input, codec: this.codec });\n      }\n    }\n    return [];\n  }\n\n  private stop() {\n    this.clearBuffer();\n\n    this.onNeedKeyFrame.allUnsubscribe();\n  }\n\n  private clearBuffer() {\n    this.rtpBuffer.forEach((b) => b.rtp!.clear());\n    this.rtpBuffer = [];\n    this.frameFragmentBuffer = undefined;\n  }\n\n  private checkFinalPacket({ rtp, time }: DepacketizerInput): boolean {\n    if (!this.options.isFinalPacketInSequence) {\n      throw new Error(\"isFinalPacketInSequence not exist\");\n    }\n\n    const { sequenceNumber } = rtp!.header;\n    if (this.lastSeqNum != undefined) {\n      const expect = uint16Add(this.lastSeqNum, 1);\n      if (uint16Gt(expect, sequenceNumber)) {\n        this.internalStats[\"unExpect\"] = {\n          expect,\n          sequenceNumber,\n          codec: this.codec,\n          at: new Date().toISOString(),\n          count: (this.internalStats[\"unExpect\"]?.count ?? 0) + 1,\n        };\n        return false;\n      }\n      if (uint16Gt(sequenceNumber, expect)) {\n        this.internalStats[\"packetLost\"] ??= [];\n        if (this.internalStats[\"packetLost\"].length > 10) {\n          this.internalStats[\"packetLost\"].shift();\n        }\n        this.internalStats[\"packetLost\"].push({\n          expect,\n          sequenceNumber,\n          codec: this.codec,\n          at: new Date().toISOString(),\n        });\n        this.internalStats[\"packetLostCount\"] ??= 0;\n        this.internalStats[\"packetLostCount\"]++;\n\n        this.frameBroken = true;\n        this.clearBuffer();\n      }\n    }\n\n    this.rtpBuffer.push({ rtp, time });\n    this.lastSeqNum = sequenceNumber;\n\n    let finalPacket: number | undefined;\n    for (const [i, { rtp }] of enumerate(this.rtpBuffer)) {\n      if (this.options.isFinalPacketInSequence(rtp!.header)) {\n        finalPacket = i;\n        break;\n      }\n    }\n    if (finalPacket == undefined) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"]}