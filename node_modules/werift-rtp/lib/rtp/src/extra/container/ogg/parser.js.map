{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../../../../src/extra/container/ogg/parser.ts"],"names":[],"mappings":"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","sourcesContent":["export interface Page {\n  granulePosition: number;\n  segments: Buffer[];\n  segmentTable: number[];\n}\n\nexport class OggParser {\n  pages: Page[] = [];\n\n  private checkSegments(page?: Page) {\n    if (!page) {\n      return { ok: true };\n    }\n    for (let i = 0; i < page.segmentTable.length; i++) {\n      const segment = page.segments[i];\n      const table = page.segmentTable[i];\n      if (segment.length !== table) {\n        return { invalid: i };\n      }\n    }\n    return { ok: true };\n  }\n\n  exportSegments() {\n    let i = 0;\n    const pages: Page[] = [];\n    for (; i < this.pages.length; i++) {\n      const page = this.pages[i];\n      const { invalid } = this.checkSegments(page);\n      if (invalid) {\n        break;\n      }\n      pages.push(page);\n    }\n    this.pages = this.pages.slice(i);\n    return pages.flatMap((page) => page.segments);\n  }\n\n  read(buf: Buffer) {\n    for (let index = 0; ; ) {\n      if (index > buf.length) break;\n      try {\n        const lastPage = this.pages.at(-1);\n        const invalid = this.checkSegments(lastPage).invalid;\n\n        if (lastPage && invalid) {\n          for (let i = invalid; i < lastPage.segmentTable.length; i++) {\n            const diff = lastPage.segmentTable[i] - lastPage.segments[i].length;\n            lastPage.segments[i] = Buffer.concat([\n              lastPage.segments[i],\n              buf.subarray(index, index + diff),\n            ]);\n            index += diff;\n          }\n        } else {\n          const magic = buf.subarray(index, index + 4).toString();\n          if (magic !== \"OggS\") {\n            break;\n          }\n          index += 4; // skip magic\n          index += 1; // skip version\n          const headerType = buf.readUInt8(index);\n          index += 1; // skip header type\n          const granulePosition = buf.readBigInt64LE(index);\n          index += 8; // skip granule position\n          const bitstreamSerialNumber = buf.readUInt32LE(index);\n          index += 4; // skip bitstream serial number\n          const pageSequenceNumber = buf.readUInt32LE(index);\n          index += 4; // skip page sequence number\n          const pageChecksum = buf.readUInt32LE(index);\n          index += 4; // skip page checksum\n          const pageSegments = buf.readUInt8(index);\n          index += 1; // skip page segments\n          const segmentTable = buf.subarray(index, index + pageSegments);\n          index += pageSegments; // skip segment table\n\n          const segments: Buffer[] = [];\n          for (let i = 0; i < pageSegments; i++) {\n            const segment = segmentTable.readUInt8(i);\n            const segmentData = buf.subarray(index, index + segment);\n            index += segment;\n            segments.push(segmentData);\n          }\n\n          this.pages.push({\n            segments,\n            granulePosition: Number(granulePosition),\n            segmentTable: [...segmentTable.map((s) => s)],\n          });\n        }\n      } catch (error) {\n        break;\n      }\n    }\n    return this;\n  }\n}\n"]}